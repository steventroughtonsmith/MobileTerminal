/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 * Reserved.  This file contains Original Code and/or Modifications of
 * Original Code as defined in and that are subject to the Apple Public
 * Source License Version 1.0 (the 'License').  You may not use this file
 * except in compliance with the License.  Please obtain a copy of the
 * License at http://www.apple.com/publicsource and read it before using
 * this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License."
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <sys/cdefs.h>
#include <stdio.h>
#include "yp.h"
#include "ypv1.h"
#ifndef lint
__unused static char rcsid[] = "$OpenBSD: ypserv_xdr_v1.c,v 1.1 1997/03/30 20:51:22 maja Exp $";
#endif /* not lint */

bool_t
xdr_ypreqtype(xdrs, objp)
	XDR *xdrs;
	ypreqtype *objp;
{

	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_ypresptype(xdrs, objp)
	XDR *xdrs;
	ypresptype *objp;
{

	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_yprequest(xdrs, objp)
	XDR *xdrs;
	yprequest *objp;
{
	if (!xdr_ypreqtype(xdrs, &objp->yp_reqtype)) {
		printf("error 1\n");
		return (FALSE);
	}
	switch (objp->yp_reqtype) {
	case YPREQ_KEY:
		if (!xdr_ypreq_key(xdrs, &objp->yp_reqbody.yp_req_keytype)) {
			printf("error 2\n");
			return (FALSE);
		}
		break;
	case YPREQ_NOKEY:
		if (!xdr_ypreq_nokey(xdrs, &objp->yp_reqbody.yp_req_nokeytype)) {
			printf("error 3\n");
			return (FALSE);
		}
		break;
	case YPREQ_MAP_PARMS:
		if (!xdr_ypmap_parms(xdrs, &objp->yp_reqbody.yp_req_map_parmstype)) {
			printf("error 4\n");
			return (FALSE);
		}
		break;
	default:
		printf("error 5\n");
		return (FALSE);	 	
	}
	return (TRUE);
}

bool_t
xdr_ypresponse(xdrs, objp)
	XDR *xdrs;
	ypresponse *objp;
{

	if (!xdr_ypresptype(xdrs, &objp->yp_resptype)) {
		return (FALSE);
	}
	switch (objp->yp_resptype) {
	case YPRESP_VAL:
		if (!xdr_ypresp_val(xdrs, &objp->yp_respbody.yp_resp_valtype)) {
			return (FALSE);
		}
		break;
	case YPRESP_KEY_VAL:
		if (!xdr_ypresp_key_val(xdrs, &objp->yp_respbody.yp_resp_key_valtype)) {
			return (FALSE);
		}
		break;
	case YPRESP_MAP_PARMS:
		if (!xdr_ypmap_parms(xdrs, &objp->yp_respbody.yp_resp_map_parmstype)) {
			return (FALSE);
		}
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

